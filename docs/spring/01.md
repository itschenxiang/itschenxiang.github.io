# Spring 编程常见错误
## Spring 生命周期常见错误
#### 示例
有如下示例：
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
@Component
public class LightMgrService {
  @Autowired
  private LightService lightService;
  public LightMgrService() {
    lightService.check(); // 1
  }
}
```
会在`1`处抛出空指针异常。

#### 分析
如下时序图描述了Spring启动的一些关键点：
![](../../imgs/6ff70ab627711065bc17c54c001ef08a.png)

图中主要包括三部分：
* 第一部分，将一些必要的系统类，比如 Bean 的后置处理器类，注册到 Spring 容器，其中就包括这里关注的 CommonAnnotationBeanPostProcessor 类；
* 第二部分，将这些后置处理器实例化，并注册到 Spring 的容器中；
* 第三部分，实例化所有用户定制类，调用后置处理器进行辅助装配、类初始化等等。

现在重点看下第三部分，即 Spring 初始化单例类的一般过程，基本都是`getBean()->doGetBean()->getSingleton()`，如果发现 Bean 不存在，则调用`createBean()->doCreateBean()`进行实例化。`doCreateBean()`的源代码如下：
```java

protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
    throws BeanCreationException {
    //省略非关键代码
  if (instanceWrapper == null) {
    instanceWrapper = createBeanInstance(beanName, mbd, args); // 1
  }
  final Object bean = instanceWrapper.getWrappedInstance();

    //省略非关键代码
    Object exposedObject = bean;
    try {
       populateBean(beanName, mbd, instanceWrapper); // 2
       exposedObject = initializeBean(beanName, exposedObject, mbd); // 3
    }
    catch (Throwable ex) {
    //省略非关键代码
}
```

上述代码完整地展示了 Bean 初始化的三个关键步骤：
1. createBeanInstance
2. populateBean，以及第 13 行的
3. initializeBean

分别对应**实例化 Bean，注入 Bean 依赖，以及初始化 Bean**（例如执行`@PostConstruct`标记的方法 ）这三个功能，这也和上述时序图的流程相符。

通过分析知道了问题的根源，就是在于使用 @Autowired 直接标记在成员属性上而引发的装配行为是发生在构造器执行之后的。

#### 解决方案
1. 使用构造器参数来隐式注入是一种 Spring 最佳实践
```java
@Component
public class LightMgrService {

    private LightService lightService;

    public LightMgrService(LightService lightService) {
        this.lightService = lightService;
        lightService.check();
    }
}
```

2. Spring 在类属性完成注入之后，会回调用户定制的初始化方法。即**在 populateBean 方法之后**，会调用 initializeBean 方法：
```java
protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {
   //省略非关键代码 
   if (mbd == null || !mbd.isSynthetic()) {
      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
   }
   try {
      invokeInitMethods(beanName, wrappedBean, mbd);
   }
   //省略非关键代码 
}
```
    可以看到 applyBeanPostProcessorsBeforeInitialization 和 invokeInitMethods 这两个关键方法的执行，它们分别处理了 @PostConstruct 注解和 InitializingBean 接口这两种不同的初始化方案的逻辑。
    因此，另外两种解决方案就很明显了：
```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
@Component
public class LightMgrService {
  @Autowired
  private LightService lightService;
  
  @PostConstruct
  public void init() {
       lightService.check();
  }
}
```
```java
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
@Component
public class LightMgrService implements InitializingBean {
    @Autowired
    private LightService lightService;
  
    @Override
    public void afterPropertiesSet() throws Exception {
        lightService.check();
    }
}
```
